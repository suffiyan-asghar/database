-- Q1A
CREATE TABLE CUSTOMER
(
    CID VARCHAR2(3) PRIMARY KEY,
    CNAME VARCHAR2(25),
    CREDIT_LIMIT NUMBER,
    CREDIT_BALANCE NUMBER
);

INSERT INTO CUSTOMER VALUES ('C01', 'Ahmed Khan', 1000, 0);
INSERT INTO CUSTOMER VALUES ('C02', 'Fatima Ali', 1500, 0);
INSERT INTO CUSTOMER VALUES ('C03', 'Bilal Raza', 2000, 0);
COMMIT;

CREATE TABLE SALES
(
    SID NUMBER PRIMARY KEY,
    SDATE DATE DEFAULT SYSDATE,
    PCODE VARCHAR2(3),
    CID VARCHAR2(3),
    QTY NUMBER,
    RATE NUMBER,
    AMOUNT NUMBER,
    FOREIGN KEY (CID) REFERENCES CUSTOMER(CID)
);

DROP TRIGGER sales_before_insert;

CREATE OR REPLACE TRIGGER sales_before_insert
BEFORE INSERT ON SALES
FOR EACH ROW
DECLARE
    v_rows_updated INTEGER;
BEGIN
    UPDATE CUSTOMER
    SET CREDIT_BALANCE = NVL(CREDIT_BALANCE, 0) + :NEW.AMOUNT
    WHERE CID = :NEW.CID;
    
    v_rows_updated := SQL%ROWCOUNT;
END;
/

SELECT * FROM SALES;

INSERT INTO SALES (SID, PCODE, CID, QTY, RATE, AMOUNT)
VALUES (500, 'P10', 'C02', 2, 75, 150);

INSERT INTO SALES (SID, PCODE, CID, QTY, RATE, AMOUNT)
VALUES (501, 'P11', 'C02', 3, 40, 120);

COMMIT;

SELECT * FROM CUSTOMER;

-- Q1B
CREATE OR REPLACE TRIGGER sales_before_del
BEFORE DELETE ON SALES
FOR EACH ROW
BEGIN
    UPDATE CUSTOMER
    SET CREDIT_BALANCE = CREDIT_BALANCE - :OLD.AMOUNT
    WHERE CID = :OLD.CID;
END;
/

SELECT * FROM SALES;

INSERT INTO SALES VALUES (502, SYSDATE, 'P12', 'C02', 5, 30, 150);
COMMIT;

DELETE FROM SALES WHERE SID = 502;
COMMIT;

SELECT * FROM SALES;

-- Q1C
DROP TRIGGER sales_before_insert;
DROP TRIGGER sales_before_del;

CREATE OR REPLACE TRIGGER sales_insert_del
BEFORE INSERT OR DELETE ON SALES
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        UPDATE CUSTOMER
        SET CREDIT_BALANCE = NVL(CREDIT_BALANCE, 0) + :NEW.AMOUNT
        WHERE CID = :NEW.CID;
    ELSIF DELETING THEN
        UPDATE CUSTOMER
        SET CREDIT_BALANCE = CREDIT_BALANCE - :OLD.AMOUNT
        WHERE CID = :OLD.CID;
    END IF;
END;
/

SELECT * FROM SALES;
SELECT * FROM CUSTOMER;

INSERT INTO SALES (SID, PCODE, CID, QTY, RATE, AMOUNT) 
VALUES (503, 'P13', 'C02', 4, 25, 100);
COMMIT;

SELECT * FROM SALES;
SELECT * FROM CUSTOMER;

DELETE FROM SALES WHERE SID = 503;
COMMIT;

SELECT * FROM SALES;
SELECT * FROM CUSTOMER;

-- Q2A
CREATE TABLE ORDERS (
    ORDER_ID NUMBER(5) PRIMARY KEY,
    QUANTITY NUMBER(4),
    COST_PER_ITEM NUMBER(6,2),
    TOTAL_COST NUMBER(8,2),
    DISCOUNT NUMBER(2),
    FINAL_CHARGED NUMBER(8,2)
);

-- Q2B
CREATE OR REPLACE TRIGGER TOTAL_COST
BEFORE INSERT ON ORDERS
FOR EACH ROW
BEGIN
    :NEW.TOTAL_COST := :NEW.QUANTITY * :NEW.COST_PER_ITEM;
    :NEW.FINAL_CHARGED := :NEW.TOTAL_COST * (1 - (:NEW.DISCOUNT / 100));
END;
/

-- Q2C
INSERT INTO ORDERS (ORDER_ID, QUANTITY, COST_PER_ITEM, DISCOUNT) 
VALUES (1, 15, 150, 20);

SELECT * FROM ORDERS;

-- Q2D
INSERT INTO ORDERS (ORDER_ID, QUANTITY, COST_PER_ITEM, DISCOUNT) 
VALUES (2, 25, 300, 15);

SELECT * FROM ORDERS;

-- Q3A
CREATE TABLE CURRENCY_CON (
    CID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, 
    CURRENCY VARCHAR2(10) NOT NULL UNIQUE,             
    RATE NUMBER(10, 4) NOT NULL                         
);

CREATE TABLE FLUCTUATIONS (
    RECDATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 
    CURRENCY VARCHAR(3) NOT NULL,
    DIFFERENCE DECIMAL(10, 4) NOT NULL
);

-- Q3B
INSERT INTO CURRENCY_CON (CURRENCY, RATE) VALUES ('USD', 280.50);
INSERT INTO CURRENCY_CON (CURRENCY, RATE) VALUES ('GBP', 350.75);
INSERT INTO CURRENCY_CON (CURRENCY, RATE) VALUES ('EUR', 300.25);
COMMIT;

SELECT * FROM CURRENCY_CON;

-- Q3C
CREATE OR REPLACE TRIGGER TRG_LOG_FLUCTUATIONS
AFTER INSERT OR UPDATE OF RATE ON CURRENCY_CON
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO FLUCTUATIONS (RECDATE, CURRENCY, DIFFERENCE)
        VALUES (SYSDATE, :NEW.CURRENCY, 0); 
    ELSIF UPDATING('RATE') THEN
        INSERT INTO FLUCTUATIONS (RECDATE, CURRENCY, DIFFERENCE)
        VALUES (SYSDATE, :NEW.CURRENCY, :NEW.RATE - :OLD.RATE);
    END IF;
END;
/

-- Q4A
CREATE TABLE WORKER (
    WORKERID INT PRIMARY KEY,
    LNAME VARCHAR2(255) NOT NULL,
    GENDER CHAR(10),
    SALARY DECIMAL(10, 2),
    COMMISSION DECIMAL(10, 2),
    DEPTID INT
);

-- Q4B
CREATE SEQUENCE WORKERSEQUENCE
START WITH 100
INCREMENT BY 5;

-- Q4C
CREATE OR REPLACE TRIGGER TRIGGERWORKERID
BEFORE INSERT ON WORKER
FOR EACH ROW
BEGIN
    :NEW.WORKERID := WORKERSEQUENCE.NEXTVAL;
END;
/

-- Q4D
INSERT INTO WORKER (LNAME, GENDER, SALARY, COMMISSION, DEPTID) 
VALUES('Siddiqui', 'Female', 55000.0, 1200.0, 101);

INSERT INTO WORKER (LNAME, GENDER, SALARY, COMMISSION, DEPTID) 
VALUES('Chaudhry', 'Male', 72000.0, 1800.0, 102);

-- Q5A
CREATE TABLE ORDERHEADER(
    ORDERID INT PRIMARY KEY,
    ODATE DATE,
    CUSTID INT,
    TOTAL NUMBER(10, 2)
);

CREATE TABLE ORDER_ITEM(
    ORDERID INT,
    ITEMID INT,
    QTY INT,
    SUBTOTAL NUMBER(10, 2),
    PRIMARY KEY(ORDERID, ITEMID),
    FOREIGN KEY(ORDERID) REFERENCES ORDERHEADER(ORDERID) 
);

-- Q5B
CREATE OR REPLACE TRIGGER UPDATETOTAL
AFTER INSERT OR UPDATE OR DELETE ON ORDER_ITEM
DECLARE
    v_orderID INT;
BEGIN
    FOR order_rec IN (SELECT DISTINCT ORDERID FROM ORDER_ITEM) 
    LOOP
        UPDATE ORDERHEADER
        SET TOTAL = (SELECT NVL(SUM(SUBTOTAL), 0) FROM ORDER_ITEM WHERE ORDERID = order_rec.ORDERID) 
        WHERE ORDERID = order_rec.ORDERID;
    END LOOP;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error: ' || SQLERRM);
END;
/

-- Q5C
INSERT INTO ORDERHEADER (ORDERID, ODATE, CUSTID) VALUES(1, SYSDATE, 1);
INSERT INTO ORDER_ITEM VALUES(1, 1, 10, 2500);
INSERT INTO ORDER_ITEM VALUES(1, 2, 5, 1500);

-- Q6
CREATE OR REPLACE FUNCTION AVERAGE_DEPT_SALARY (
    P_DEPTNAME IN VARCHAR2
) RETURN NUMBER
IS
    V_AVG_SALARY NUMBER(10,2);
BEGIN
    SELECT AVG(E.SALARY) INTO V_AVG_SALARY FROM EMPLOYEES E
    JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
    WHERE UPPER(D.DEPARTMENT_NAME) = UPPER(P_DEPTNAME);
    
    RETURN V_AVG_SALARY;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE;
END AVERAGE_DEPT_SALARY;
/

SELECT AVERAGE_DEPT_SALARY('IT') AS "IT Department Average Salary" FROM DUAL;
SELECT AVERAGE_DEPT_SALARY('Sales') AS "Sales Department Average Salary" FROM DUAL;
SELECT AVERAGE_DEPT_SALARY('Finance') AS "Finance Department Average Salary" FROM DUAL;

-- Q7
CREATE OR REPLACE PROCEDURE PRINTREGIONMAXSALARY
IS
    CURSOR REGION_MAX_SAL_CUR IS
        SELECT R.REGION_NAME, MAX(E.SALARY) AS MAX_SALARY, COUNT(DISTINCT E.EMPLOYEE_ID) AS EMPLOYEE_COUNT 
        FROM REGIONS R
        JOIN COUNTRIES C ON R.REGION_ID = C.REGION_ID
        JOIN LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
        JOIN DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
        JOIN EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
        GROUP BY R.REGION_NAME
        ORDER BY MAX_SALARY DESC;
    
    V_REGION_NAME REGIONS.REGION_NAME%TYPE;
    V_MAX_SALARY EMPLOYEES.SALARY%TYPE;
    V_EMP_COUNT NUMBER;
    V_TOTAL_MAX NUMBER := 0;
BEGIN
    DBMS_OUTPUT.PUT_LINE(RPAD('Region Name', 25) || RPAD('Max Salary', 15) || 'Employee Count');
    DBMS_OUTPUT.PUT_LINE('--------------------------------------------------------');
    
    OPEN REGION_MAX_SAL_CUR;
    LOOP
        FETCH REGION_MAX_SAL_CUR INTO V_REGION_NAME, V_MAX_SALARY, V_EMP_COUNT;
        EXIT WHEN REGION_MAX_SAL_CUR%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE(RPAD(V_REGION_NAME, 25) || RPAD('$' || TO_CHAR(V_MAX_SALARY, '999,999.99'), 15) || TO_CHAR(V_EMP_COUNT));
        
        IF V_MAX_SALARY > V_TOTAL_MAX THEN
            V_TOTAL_MAX = V_MAX_SALARY;
        END IF;
    END LOOP;
    
    CLOSE REGION_MAX_SAL_CUR;

    DBMS_OUTPUT.PUT_LINE('--------------------------------------------------------');
    DBMS_OUTPUT.PUT_LINE('Overall Maximum Salary: $' || TO_CHAR(V_TOTAL_MAX, '999,999.99'));
    
EXCEPTION
    WHEN OTHERS THEN
        IF REGION_MAX_SAL_CUR%ISOPEN THEN
            CLOSE REGION_MAX_SAL_CUR;
        END IF;
        DBMS_OUTPUT.PUT_LINE('Error occurred: ' || SQLERRM);
        RAISE;
END PRINTREGIONMAXSALARY;
/

SET SERVEROUTPUT ON SIZE 10000;
EXECUTE PRINTREGIONMAXSALARY;

-- Q8
CREATE OR REPLACE FUNCTION COUNTMULTIJOBHISTORY
RETURN NUMBER
IS
    V_COUNT NUMBER;
BEGIN
    SELECT COUNT(DISTINCT EMPLOYEE_ID) INTO V_COUNT FROM JOB_HISTORY
    GROUP BY EMPLOYEE_ID HAVING COUNT(*) > 1;
    
    IF V_COUNT IS NULL THEN
        V_COUNT := 0;
    END IF;

    RETURN V_COUNT;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
    WHEN TOO_MANY_ROWS THEN
        SELECT COUNT(*) INTO V_COUNT FROM (
            SELECT EMPLOYEE_ID FROM JOB_HISTORY
            GROUP BY EMPLOYEE_ID HAVING COUNT(*) > 1
        );
        RETURN V_COUNT;
    WHEN OTHERS THEN
        RAISE;
END COUNTMULTIJOBHISTORY;
/

SELECT COUNTMULTIJOBHISTORY() AS "Employees with Multiple Job Histories" FROM DUAL;
SELECT 'Total employees with multiple job history records: ' || COUNTMULTIJOBHISTORY() AS RESULT FROM DUAL;